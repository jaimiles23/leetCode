LeetCode post available [here](https://leetcode.com/problems/k-th-symbol-in-grammar/discuss/438528/Explanation-Python)

# Time Limit Exceeded Challenge
I initially approached this problem using a bottom-up, dynamic programming algorithm. This algorithm starts at the top of the pyramid, `0`, and extrapolates subsequent rows:
1.	0
2.	01
3.	0110
4.	01101001
5.	…

However, this method requires calculating N rows of the pyramid one at a time. This method inevitably runs into the _Time Limit Exceeded_ error on the 15th test case with the following parameters:
```
N = 30
K = 434991989
```

# Using a Top-Down Approach
The top-down approach avoids creating each row of the pyramid. This approach abides to 2 principles to determine the `K`th index of the `N`th row.
1.	The value of K is determined by the Nth – 1 row.
2.	The Kth index is dependent on the Kth // 2 index of the Nth – 1 row, such that:
    a.	If the Kth index is odd, it will be the same as the Kth index.
    b.	If the Kth index is even, it will be the inverse of the Kth index.

Let’s break these principles down one at a time:

**The value of K is determined by the Nth – 1 row**
This may seem tedious to acknowledge, but it is imperative to formulate the 2nd principle. 
-	Row 2 is `01` because Row 1 is `0`.
-	Row 3 is `0110` because Row 2 is `01`.

**The Kth index is dependent on the Kth // 2 index of the Nth – 1 row**
Each level of the pyrmaid is twice as long as the previous level. This is because the next row is built by transforming each index into 2 numbers.
```
    Row      Length      Expression
    1        1           2 ^ 0
    2        2           2 ^ 1
    3        4           2 ^ 2
    4        8           2 ^ 3
    ...
```
As such, you can determine index `K` of row `N` by looking at index `K // 2` of row `N – 1`. 

Parts (a) and (b) of Principle 2 are derived by the method of number transformation from the previous, `N – 1`, row.  
_Note:_ Remember that this problem uses a base index of 1. 

**If the Kth index is odd, it will be the same as the Kth index.**
Because the numbers are transformed as:

```
	N – 1	        	N 
	0       	->      01
	1       	->      10
```

The odd `K` indices are the same as the `K // 2` index of the previous row. For instance, `01[1]  == 0`, which is the number that generated it in the previous row.

**If the Kth index is even, it will be the inverse of the Kth index.**
Using this same logic, if the Kth index is even, it will be the inverse of the number that generated it.

`01[2]  == 1`, while the pattern `01` was generated by the number `0` in the previous row. Thus, the odd index [2] is the inverse of `0`.

# Code
Using these 2 principles, a recursive top-down approach can determine the Kth index. 

Python code as follows:
```
class Solution():+
    def kthGrammar(self, N: int, K: int) -> int:        
	# Base case for the top and left side of pyramid
        if N == 1 or K == 1:
            return 0
        
        if K % 2 == 1:
            return self.kthGrammar(N - 1, K // 2 + 1)
        
        if self.kthGrammar(N - 1, K // 2) == 1: 
            return 0
        else:
            return 1
```

