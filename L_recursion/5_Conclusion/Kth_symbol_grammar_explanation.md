

This problem was especially difficult for me to understand, so I wrote an explanation of my solution for others who are struggling. LeetCode post available [here](https://leetcode.com/problems/k-th-symbol-in-grammar/discuss/438528/Explanation-Python)

**Time Limit Exceeded Challenge**
I initially approached this problem using a bottom-up, dynamic programming algorithm. This algorithm starts at the top of the pyramid, `0`, and extrapolates subsequent rows:
1.	0
2.	01
3.	0110
4.	01101001
5.	…

However, this method requires calculating N rows of the pyramid, one at a time, and inevitably runs into the _Time Limit Exceeded_ on the 15th test case when the following parameters are passed:
```
N = 30
K = 434991989
```

**Using a Top-Down Approach**
The top-down approach avoids creating each row of the pyramid via abidance to 2 principles to determine the `K`th index of the `N`th row.
1.	The value of K is determined by the Nth – 1 row.
2.	The Kth index is dependent on the Kth // 2 index of the Nth – 1 row, such that:
    a.	If the Kth index is odd, it will be the same as the Kth index.
    b.	If the Kth index is even, it will be the inverse of the Kth index.

Let’s break these principles down one at a time:

**The value of K is determined by the Nth – 1 row**
This may seem tedious to acknowledge, but it is important to validate the 2nd principle. 
-	Row 2 is `01` because Row 1 is `0`.
-	Row 3 is `0110` because Row 2 is `01`.

**The Kth index is dependent on the Kth // 2 index of the Nth – 1 row**
Because each number is transformed into two other numbers with each subsequent pyramid level, each level will be twice as long as the previous level:
-	Len(row1) == 1
-	Len(row2) == 2
-	Len(row3) == 4
-	Len(row4) == 8
-	Etc.
As such, you can determine index `K` of row `N` by looking at index `K // 2` of row `N – 1`. 

Principle 2 parts (a) and (b) are derived by the transformation of numbers from the previous, `N – 1`, row.  

**If the Kth index is odd, it will be the same as the Kth index.**
Because the numbers are transformed as:

```
	N – 1	        	N 
	0       	->      01
	1       	->      10
```

The odd `K` indices are the same as the `K // 2` index of the previous row – remember that this problem uses a base index of 1. 
`01[1]  == 0`, which is the number that generated it in the previous row.

**If the Kth index is even, it will be the inverse of the Kth index.**
Using this same logic, if the Kth index is even, it will be the inverse.

`01[2]  == 1`, while the pattern `01` was generated by the number `0` in the previous row. Thus, the odd index [2] is the inverse of the number that generated it, `0`.

Using these principles, a recursive top-down approach can determine the Kth index. 

Python code as follows:
```
class Solution():+
    def kthGrammar(self, N: int, K: int) -> int:        
	# Base case for the top and left side of pyramid
        if N == 1 or K == 1:
            return 0
        
        if K % 2 == 1:
            return self.kthGrammar(N - 1, K // 2 + 1)
        
        if self.kthGrammar(N - 1, K // 2) == 1: 
            return 0
        else:
            return 1
```

